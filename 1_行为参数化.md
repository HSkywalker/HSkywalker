# 行为参数化

**行为参数刷是可以帮助处理频繁变更的需求的一种软件开发模式。**

## 问题引入

如果对于一堆苹果要进行筛选，首先定义一个苹果类，以及一个苹果集合：

```java
public class Apple {
    public static List<Apple> apples = Arrays.asList(new Apple("green", 1500), 
            new Apple("red", 1200),
            new Apple("yellow",1300),
            new Apple("blue",1300),
            new Apple("green",1200));
            ;
    private String color;
    private int weight;

    public Apple(String color, int weight) {
        this.color = color;
        this.weight = weight;
    }
    //getter && setter
    ...}
```

### 简单的if筛选

> 1.0 通过外循环和if条件筛选

```java
List<Apple> TestingCollection= Apple.apples;
//the condition filter
for(Apple apple:TestingCollection) {
    if(apple.color.equals("red")) {
        System.out.println(apple);
    }
}
```

> 2.0 通过外循环和函数进行筛选

```java
public class ChangingDemands2 {
    public static void main(String[] args){
        ArrayList<Apple> filteredResult=new ArrayList<>();
        filteredResult=filterByColor(Apple.apples);
        for (Apple apple : filteredResult) {
            System.out.println(apple);
        }
    }
    public static ArrayList<Apple> filterByColor(List<Apple> input){
        ArrayList<Apple> apples = new ArrayList<Apple>();
        for (Apple apple:input){
            if (apple.getColor().equals("red")) apples.add(apple);
        }
        return apples;
    }
}
```

这种方案可以进一步改进，比如传入一个参数来代表，要筛选的颜色:

```java
public static ArrayList<Apple> filterApples(List<Apple> input,String color,int weight,boolean flag){
    ArrayList<Apple> apples = new ArrayList<>();
    for (Apple apple:input){
        if(apple.getColor().equals(color)&&
                (!flag||apple.getWeight()>=weight)){
            apples.add(apple);
        }
    }
    return apples;
}
```

**这个时候，不仅仅要筛选颜色，还需要筛选重量呢？**如果这个时候再加入一个筛选重量的函数，就会再一次遍历然后if筛选，**违反了程序设计中的`DRY(Don't repeat yourself`原则**。如果在原函数上修改的话，也会有着代码随着需求变更更改量大的问题。

### 行为参数化筛选

> 3.0 参数化行为

1. 定义一个筛选接口，用于引用抽象筛选对象，里面定义了一个**谓词（一个返回`boolean`值的函数）**

```java
interface AppleFilter{
    boolean filter(Apple apple);
}
```

2. 编写实现该接口的多个筛选类

```java
class AppleColorFilter implements AppleFilter{
    @Override
    public boolean filter(Apple apple) {
        return apple.getColor().equals("red");
    }
}
class  AppleWeightFilter implements AppleFilter{
    @Override
    public boolean filter(Apple apple) {
        return apple.getWeight()>100;
    }
}
```

3. 定义一个筛选方法，可以通过筛选类来进行筛选

```java
public class ConfigurateBehavior {
    public static void main(String[] args) {
        ArrayList<Apple> result=filterApples(Apple.apples,new AppleColorFilter());
        for (Apple apple:result){
            System.out.println(apple);
        }
    }
    public static ArrayList<Apple> filterApples(List<Apple> input, AppleFilter appleFilter){
        ArrayList<Apple> apples = new ArrayList<>();
        for (Apple apple : input) {
            //引用筛选类的筛选方法来实现筛选。
            if(appleFilter.filter(apple)) apples.add(apple);
        }
        return apples;
    }
}

```

这样就可以创建不同实现了该接口的对象，然后将其传递给筛选方法，来进行筛选。即**参数化了筛选行为，将其传递给了`filterApples`方法**，这使得我们建立了一个筛选逻辑工具箱，当要具体应用该逻辑时，直接传入这个筛选逻辑类就可以了。



## 引入Lambda表达式

目前，要将新的行为传入给`filterApples`方法时，不得不声明好几个实现了`AppleFilter`接口的类，然后重写它的`filter`方法，最后在使用时，要在`filterApples`参数列表中，实例化这个对象，十分啰嗦和费时间，这也是**Lambda表达式**的诞生契机。

### 匿名类

匿名类运行同时声明和实例化一个类，省去了此前在外部声明然后实例化的过程；

```java
public class AnnonymousClass {
    public static void main(String[] args) {
        ArrayList<Apple> result=ConfigurateBehavior.filterApples(Apple.apples, new AppleFilter() {
            @Override
            public boolean filter(Apple apple) {
                return apple.getColor().equals("yellow");
            }
        });
        for (Apple apple : result) {
            System.out.println(apple);
        }
    }
}
```

### Lambda表达式

这一段使用匿名类的表达式可以进行简写：

```java
filterApples(Apple.apples, new AppleFilter() {
            @Override
            public boolean filter(Apple apple) {
                return apple.getColor().equals("yellow");
            }
        });
```

简写的结果为：`filterApples(Apple.apples,apple->apple.getColor().equals("yellow"));`

> 使用泛型提升接口的泛用性

然后，我们可以将此前定义的接口使用泛型抽象化：

```java
interface AppleFilter<T>{
    boolean filter(T item);
}
```

对于筛选的filter也可泛型进行泛化：

```java
public class LambdaExpression {
    public static void main(String[] args) {
        ArrayList<Apple> result=ConfigurateBehavior.filterApples(Apple.apples,a->a.getColor().equals("red"));
    }
    public static <T> ArrayList<T> filter(List<T> t, Predicate p){
        ArrayList<T> re=new ArrayList<T>();
        for (T t1 : t) {
            if (p.test(t1)) {
                re.add(t1);
            }
        }
        return re;
    }
}

```



**行为参数化，就是一个函数可以接受不同的行为作为参数，并在内部进行使用，完成不同行为大的能力。**